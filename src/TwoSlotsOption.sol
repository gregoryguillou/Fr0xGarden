// SPDX-License-Identifier: CC-BY-NC-ND-4.0 (Creative Commons Attribution Non Commercial No Derivatives 4.0 International)
pragma solidity ^0.8.17;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {UniswapV3TWAP} from "src/UniswapV3TWAP.sol";

/// @title TwoSlotsOption
/// @author @fr0xMaster
/// @notice Mutual Slots implementation of Two Slots Option contract.

/// @notice Status of a Contest. The status can alternate between 3 different states.
// OPEN is the default status when a new Contest is created. In this status, if the contest is not mature, users can buy a slot option.
// RESOLVED is the status assigned once the Contest has reached maturity and a winning slot has been determined in favor of a loser.
// REFUNDABLE is the status assigned once the v has reached its maturity but the conditions are not met to determine a winner.
enum ContestStatus {
    UNDEFINED,
    OPEN,
    RESOLVED,
    REFUNDABLE
}

enum SlotType {
    LESS,
    MORE
}

enum WinningSlot {
    UNDEFINED,
    LESS,
    MORE
}

/// @notice Status of an Option. The status can alternate between 3 different states.
// CREATED is the default status when a new Option is created. This status defines that an Option has been created and is attached to an address.
// CLAIMED status is assigned to a winning Option and claimed by the linked address.
// REFUND status is assigned when an Option has no winner and the linked address has been refunded its initial Option.
enum OptionStatus {
    UNDEFINED,
    CREATED,
    CLAIMED,
    REFUND
}

contract TwoSlotsOption is Ownable {
    using SafeERC20 for IERC20;

    address public FEES_COLLECTOR; // address who receives fees generated by contract activity
    address public immutable FACTORY; // address of UNISWAP V3 FACTORY.
    address public immutable TOKEN0; // address of USDC Token
    address public immutable TOKEN1; // address of ERC20 Token use for Options (ex. ETH, ARB, WBTC,...)
    uint24 public UNISWAP_POOL_FEE; // fees of the desired Uniswap pool in order to use the V3 oracle features
    uint8 public SECONDS_FOR_ORACLE_TWAP; // fees of the desired Uniswap pool in order to use the V3 oracle features
    UniswapV3TWAP uniswapV3TWAP;
    uint256 public MIN_BET; // minimum amount to bet - to avoid spam attack & underflow
    uint256 public MAX_BET_IN_SLOT; // maximum amount Bet in Slot to allow a precise redistribution of the gains
    uint8 public FEE_NUMERATOR; // numerator to calculate fees
    uint8 public FEE_DENOMINATOR; // denominator to calculate fees
    uint256 public EPOCH; // duration of an epoch expressed in seconds
    uint256 public LAST_OPEN_CONTEST_ID; // ID of last contest open.
    uint256 public lastCloseContestID; // ID of last contest close. To be close a contest need to be Resolved or Refundable
    mapping(uint256 => Contest) contests; // mapping of all contests formatted as struct.

    constructor(
        address _FEES_COLLECTOR,
        address _FACTORY,
        address _TOKEN0,
        address _TOKEN1,
        uint24 _UNISWAP_POOL_FEE,
        uint8 _SECONDS_FOR_ORACLE_TWAP,
        uint8 _FEE_NUMERATOR,
        uint8 _FEE_DENOMINATOR,
        uint256 _MIN_BET,
        uint256 _MAX_BET_IN_SLOT,
        uint256 _EPOCH
    ) {
        FEES_COLLECTOR = _FEES_COLLECTOR;
        FACTORY = _FACTORY;
        TOKEN0 = _TOKEN0;
        TOKEN1 = _TOKEN1;
        UNISWAP_POOL_FEE = _UNISWAP_POOL_FEE;
        SECONDS_FOR_ORACLE_TWAP = _SECONDS_FOR_ORACLE_TWAP;
        FEE_NUMERATOR = _FEE_NUMERATOR;
        FEE_DENOMINATOR = _FEE_DENOMINATOR;
        MIN_BET = _MIN_BET;
        MAX_BET_IN_SLOT = _MAX_BET_IN_SLOT;
        EPOCH = _EPOCH;
        uniswapV3TWAP = new UniswapV3TWAP(FACTORY, TOKEN0,TOKEN1,UNISWAP_POOL_FEE);
    }

    struct Option {
        OptionStatus optionStatus;
        uint256 amount;
    }

    struct Slot {
        uint256 totalAmount;
        uint256 payout;
        mapping(address => Option) options;
    }

    struct Odds {
        uint256 slotLess;
        uint256 slotMore;
    }

    struct AmountRemainsInSlot {
        uint256 slotLess;
        uint256 slotMore;
    }

    struct Contest {
        ContestStatus contestStatus; // Status of the current Contest
        uint256 startedAt; // Unix timestamp at contest creation
        uint256 closeAt; // Unix timestamp at deposit is closed
        uint256 maturityAt; // Unix timestamp at contest maturity
        address creator; // Address who created contest. Will receive a share of the fees generated.
        address resolver; // Address who resolve contest. Will receive a share of the fees generated.
        uint256 startingPrice; // Token price at contest creation
        uint256 maturityPrice; // Token price at contest maturity
        WinningSlot winningSlot; // Defines the winning slot once the Contest is resolved
        Slot slotLess;
        Slot slotMore;
    }

    error ContestIsAlreadyOpen(uint256 lastOpenContestID);
    error ContestNotOpen();
    error BettingPeriodExpired(uint256 actualTimestamp, uint256 closeAt);
    error InsufficientBetAmount(uint256 amountBet, uint256 minBet);
    error InsufficientBalance(uint256 userBalance, uint256 amountBet);
    error InsufficientAllowance(uint256 contractAllowance, uint256 amountBet);
    error InsufficientAmountInSlots(uint256 amountInSlotLess, uint256 amountInSlotMore, uint256 minRequired);
    error MaxAmountInSlotReached(uint256 amountBet, SlotType slot, uint256 maxBetRemaining);

    modifier isCreateable() {
        if (
            contests[LAST_OPEN_CONTEST_ID].contestStatus == ContestStatus.OPEN
                && block.timestamp < contests[LAST_OPEN_CONTEST_ID].closeAt
        ) {
            revert ContestIsAlreadyOpen({lastOpenContestID: LAST_OPEN_CONTEST_ID});
        }
        _;
    }

    modifier isContestOpen(uint256 _contestID) {
        if (contests[_contestID].contestStatus != ContestStatus.OPEN) {
            revert ContestNotOpen();
        }
        _;
    }

    modifier isContestInBettingPeriod(uint256 _contestID) {
        if (block.timestamp >= contests[_contestID].closeAt) {
            revert BettingPeriodExpired({actualTimestamp: block.timestamp, closeAt: contests[_contestID].closeAt});
        }
        _;
    }

    modifier isSufficientBetAmount(uint256 _amountToBet) {
        if (_amountToBet < MIN_BET) {
            revert InsufficientBetAmount({amountBet: _amountToBet, minBet: MIN_BET});
        }
        _;
    }

    modifier isSufficientBalance(uint256 _amountToBet) {
        if (IERC20(TOKEN0).balanceOf(msg.sender) < _amountToBet) {
            revert InsufficientBalance({userBalance: IERC20(TOKEN0).balanceOf(msg.sender), amountBet: _amountToBet});
        }
        _;
    }

    modifier isSufficientAllowance(uint256 _amountToBet) {
        if (IERC20(TOKEN0).allowance(msg.sender, address(this)) < _amountToBet) {
            revert InsufficientAllowance({
                contractAllowance: IERC20(TOKEN0).allowance(msg.sender, address(this)),
                amountBet: _amountToBet
            });
        }
        _;
    }

    modifier isSufficientAmountInSlots(uint256 _amountInSlotLess, uint256 _amountInSlotMore) {
        if (_amountInSlotLess < MIN_BET || _amountInSlotMore < MIN_BET) {
            revert InsufficientAmountInSlots({
                amountInSlotLess: _amountInSlotLess,
                amountInSlotMore: _amountInSlotMore,
                minRequired: MIN_BET
            });
        }
        _;
    }

    modifier isMaxAmountNotReached(uint256 _contestID, uint256 _amountToBet, SlotType _slotType) {
        if (getAmountBetInSlot(_contestID, _slotType) + _amountToBet > MAX_BET_IN_SLOT) {
            uint256 maxBetRemaining = MAX_BET_IN_SLOT - getAmountBetInSlot(_contestID, _slotType);
            revert MaxAmountInSlotReached({amountBet: _amountToBet, slot: _slotType, maxBetRemaining: maxBetRemaining});
        }
        _;
    }

    event CreateContest(uint256 indexed _contestID, address indexed _creator);
    event Bet(uint256 indexed _contestID, address indexed _from, uint256 _amountBet, SlotType _isSlotMore);

    /// @notice Calculate fees to be deducted from a given amount
    /// @dev Fee amount by dividing the numerator by the denominator which - e.g: 3/100 = 0.03 or 3% percent;
    /// @param _amount amount between 1e15 & 1e20.
    /// @return fees amount in wei
    function getFeeByAmount(uint256 _amount) public view returns (uint256) {
        return _amount * (FEE_NUMERATOR) / (FEE_DENOMINATOR);
    }

    function setLastOpenContestID(uint256 _id) internal {
        LAST_OPEN_CONTEST_ID = _id;
    }

    function getContestStatus(uint256 _contestID) external view returns (ContestStatus) {
        return contests[_contestID].contestStatus;
    }

    function getContestWinningSlot(uint256 _contestID) external view returns (WinningSlot) {
        return contests[_contestID].winningSlot;
    }

    function getContestStartingPrice(uint256 _contestID) external view returns (uint256) {
        return contests[_contestID].startingPrice;
    }

    function getContestMaturityPrice(uint256 _contestID) external view returns (uint256) {
        return contests[_contestID].maturityPrice;
    }

    function getContestCloseAtTimestamp(uint256 _contestID) external view returns (uint256) {
        return contests[_contestID].closeAt;
    }

    function getContestMaturityAtTimestamp(uint256 _contestID) external view returns (uint256) {
        return contests[_contestID].maturityAt;
    }

    function getContestCreator(uint256 _contestID) external view returns (address) {
        return contests[_contestID].creator;
    }

    function getContestResolver(uint256 _contestID) external view returns (address) {
        return contests[_contestID].resolver;
    }

    function getAmountBetInSlot(uint256 _contestID, SlotType _slotType) public view returns (uint256) {
        return _slotType == SlotType.LESS
            ? contests[_contestID].slotLess.totalAmount
            : contests[_contestID].slotMore.totalAmount;
    }

    function getAmountBetInOption(uint256 _contestID, SlotType _slotType, address _user)
        external
        view
        returns (uint256)
    {
        return _slotType == SlotType.LESS
            ? contests[_contestID].slotLess.options[_user].amount
            : contests[_contestID].slotMore.options[_user].amount;
    }

    function getOptionStatus(uint256 _contestID, SlotType _slotType, address _user)
        public
        view
        returns (OptionStatus)
    {
        return _slotType == SlotType.LESS
            ? contests[_contestID].slotLess.options[_user].optionStatus
            : contests[_contestID].slotMore.options[_user].optionStatus;
    }

    function getChosenSlot(uint256 _contestID, SlotType _slotType) internal view returns (Slot storage) {
        return _slotType == SlotType.LESS ? contests[_contestID].slotLess : contests[_contestID].slotMore;
    }

    function getSlotOdds(uint256 _amountInSlotLess, uint256 _amountInSlotMore)
        public
        view
        isSufficientAmountInSlots(_amountInSlotLess, _amountInSlotMore)
        returns (Odds memory)
    {
        uint256 totalGrossBet = _amountInSlotLess + _amountInSlotMore;
        uint256 fees = getFeeByAmount(totalGrossBet);
        uint256 totalNetToShareBetweenWinners = totalGrossBet - fees;
        uint256 precisionForGetOddAccurate = MAX_BET_IN_SLOT;
        uint256 oddForLess = totalNetToShareBetweenWinners * precisionForGetOddAccurate / _amountInSlotLess;
        uint256 oddForMore = totalNetToShareBetweenWinners * precisionForGetOddAccurate / _amountInSlotMore;
        return Odds({slotLess: oddForLess, slotMore: oddForMore});
    }

    /*
    function getHumanReadeableSlotOdds(uint256 _oddForLess, uint256 _oddForMore) public view returns (HumanReadeableOdds memory) {
        return HumanReadeableOdds({slotLess: totalNetBet / _amountInSlotLess, slotMore: totalNetBet / _amountInSlotMore});
        //TODO:FIX fonction pour quelle retourne des nombre plus precis (a deux chiffre apres la virgule)
    }*/

    function getAmountRemainsInSlots(
        uint256 totalNetToShareBetweenWinners,
        uint256 _amountInSlotLess,
        uint256 _amountInSlotMore
    ) public view returns (AmountRemainsInSlot memory) {
        uint256 precisionForGetOddAccurate = MAX_BET_IN_SLOT;
        uint256 oddLess = getSlotOdds(_amountInSlotLess, _amountInSlotMore).slotLess;
        uint256 oddMore = getSlotOdds(_amountInSlotLess, _amountInSlotMore).slotMore;

        uint256 amountRedisitributedIfLessWin = (_amountInSlotLess * oddLess) / precisionForGetOddAccurate;
        uint256 amountRemainingInThePoolIfLessWin = totalNetToShareBetweenWinners - amountRedisitributedIfLessWin;

        uint256 amountRedisitributedIfMoreWin = (_amountInSlotMore * oddMore) / precisionForGetOddAccurate;
        uint256 amountRemainingInThePoolIfMoreWin = totalNetToShareBetweenWinners - amountRedisitributedIfMoreWin;

        return AmountRemainsInSlot({
            slotLess: amountRemainingInThePoolIfLessWin,
            slotMore: amountRemainingInThePoolIfMoreWin
        });
    }

    function createContest() external isCreateable returns (bool) {
        uint256 newContestID = LAST_OPEN_CONTEST_ID + 1;
        contests[newContestID].contestStatus = ContestStatus.OPEN;
        contests[newContestID].startedAt = block.timestamp;
        contests[newContestID].closeAt = block.timestamp + EPOCH;
        contests[newContestID].maturityAt = block.timestamp + (EPOCH * 2);
        contests[newContestID].creator = msg.sender;
        contests[newContestID].startingPrice = uniswapV3TWAP.estimateAmountOut(TOKEN1, 1 ether, SECONDS_FOR_ORACLE_TWAP);
        setLastOpenContestID(newContestID);
        emit CreateContest(newContestID, msg.sender);
        return true;
    }

    function bet(uint256 _contestID, uint256 _amountToBet, SlotType _slotType)
        external
        isContestOpen(_contestID)
        isContestInBettingPeriod(_contestID)
        isSufficientBetAmount(_amountToBet)
        isSufficientBalance(_amountToBet)
        isSufficientAllowance(_amountToBet)
        isMaxAmountNotReached(_contestID, _amountToBet, _slotType)
        returns (bool)
    {
        Slot storage chosenSlot = getChosenSlot(_contestID, _slotType);
        chosenSlot.totalAmount += _amountToBet;
        bool isUserFirstBet = getOptionStatus(_contestID, _slotType, msg.sender) == OptionStatus.UNDEFINED;
        if (isUserFirstBet) chosenSlot.options[msg.sender].optionStatus = OptionStatus.CREATED;
        chosenSlot.options[msg.sender].amount += _amountToBet;
        emit Bet(_contestID, msg.sender, _amountToBet, _slotType);
        return true;
    }

    // TODO: Handle refund if odd is less than 1.03 because User can loose money even if i beton the good output;
}
